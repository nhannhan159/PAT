<#@ template language="C#" debug="False" hostspecific="true" #>
using System.Collections.Generic;
using PAT.Common;
using PAT.Common.Classes.Assertion;
using PAT.Common.Classes.Expressions;
using PAT.Common.Classes.Expressions.ExpressionClass;
using PAT.Common.Classes.LTS;
using PAT.Common.Classes.ModuleInterface;
using PAT.Common.Classes.Ultility;
using PAT.Common.Classes.SemanticModels.LTS.Assertion;
using <# Write(this.Host.ResolveParameterValue("","","LTSNamespace")); #>;

namespace <# Write(this.Host.ResolveParameterValue("","","AssertionsNamespace")); #>
{
    public class <# Write(this.Host.ResolveParameterValue("","","ModuleCode")); #>AssertionReachabilityWith : AssertionReachabilityWith
    {
        private DefinitionRef Process;

        public <# Write(this.Host.ResolveParameterValue("","","ModuleCode")); #>AssertionReachabilityWith(DefinitionRef processDef, string reachableState, QueryConstraintType cont, Expression constraintCondition)
            : base(reachableState, cont, constraintCondition)
        {
            Process = processDef;
        }

        public override string StartingProcess
        {
            get
            {
                return Process.ToString();
            }
        }

        public override void Initialize(SpecificationBase spec)
        {
            //initialize the ModelCheckingOptions
            base.Initialize(spec);
            
            Specification Spec = spec as Specification;
            ReachableStateCondition = Spec.DeclarationDatabase[ReachableStateLabel];

            List<string> varList = Process.GetGlobalVariables();
            varList.AddRange(ReachableStateCondition.GetVars());
            varList.AddRange(ConstraintCondition.GetVars());                        

            Valuation GlobalEnv = Spec.SpecValuation.GetVariableChannelClone(varList, Process.GetChannels());
            
            //Initialize InitialStep
            InitialStep = new Configuration(Process, Constants.INITIAL_EVENT, null, GlobalEnv, false);

            MustAbstract = Process.MustBeAbstracted();

            if (MustAbstract)
            {
                throw new ParsingException(
                    "Process " + StartingProcess +
                    " has infinite states and therefore can not be used to assert reachability with MIN/MAX constraints!",
                    AssertToken);

            }
        }
    
        //todo: override ToString method if your assertion uses different syntax as PAT
        //public override string ToString()
        //{
        //		return "";
        //}
    }
}